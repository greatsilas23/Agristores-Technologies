<!DOCTYPE html>
<head><meta name="author" content="greatsilas23"><meta name="description" content="A webpage that monitors wildlife projects"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="robots" content="follow, no-follow"><meta name="charset" content="utf-8"></head>
<body><header></header><aside></aside><article></article><footer></footer></body>
<script type="text/javascript">

let tasks = "Corporation, Secretary & Legal Services
Take and keep committee minutes of the Organization and legal duties for the Board.
Maintenance of the Board's asset register
Coordinate litigations for the Board.

Wildlife & Community Service
biodiversity conservation
climate change vulnerability assessment and mapping
bio-enterprises provision
community livelihood provision

Wildlife Security
protect wildlife
protect wildlife habitat
enhance security in protected areas for wildlife
safeguard wildlife

Infrastructure Management
management of technical resources
management of operational resources 

Planning, Partnerships & Enterprise
enhance your planning process
enhance company outcome

Human Resource & Administration
managing of human capital within an organization or industry

Finance & Accounting
recording the myriad of transactions
summarizing the myriad of transactions
reporting the myriad of transactions

Internal Audit
evaluate a company's internal controls
evaluate a company's corporate governance and accounting processes"



/*class Item{
constructor(){
}
}
class Card{
constructor(id, name, description){
this.id = id
this.name = name
this.description = description
}
}
class Tarot extends Card{
constructor(){
super()
this.cardId = 0
this.cardName = new Card('0', 'card', 'lat: 0, lon: 0, freq: 0')
}
getCardId(){
return this.cardId
}
setCardId(id){
this.cardId = id
return
}
bubbleSort(item){
if(item != {}){
for(let i = 0; i <= item.length; i++){
for(let j = 1; j <= item.length - 1; j++){
item.id[j] <= item.id[j - 1] ? {
let tmp
tmp = item.id[j - 1]
item.id[j - 1] = item.id[j]
item.id[j] = tmp } : console.log(j)
}
}
}
return item
}
getNodeList(item){
item.id--
for(let i = 0; i <= item.length; i++){
let unorderedSub = new Array()
return unorderedSub.push(item[i])
}
}
getLeft(item){
let left = getNodeList(item.id)
for(let i = 0; i <= item.length; i++){
if(left[i] <= item){
item.id--
right.push(left[i])
return getLeft(left)
} else { item.id-- 
left.push(left[i])
return getLeft(left[i]) } }
}
console.log(new Tarot().getLeft())
console.log(new Tarot().getRight())
*/
class pixel{
constructor(){
this.isNotEmpty = false
}
get(pixel){
let pixel = ''
pixel.concat('<div style="background-color: ').concat(pixel.backgroundColor).concat(';  border: solid ').concat(pixel.border).concat('; height: ').concat(pixel.height).concat('px; left: ').concat(pixel.left).concat('px; position: absolute; top: ').concat(pixel.top).concat('px; width: ').concat(pixel.width).concat('px; z-index: ').concat(pixel.z).concat(';">').concat('</div>')
this.isNotEmpty = true
}
}
class avatar{
constructor(){






this.x = new Array([[new pixel(new Object({backgroundColor[0][0], border[0][1], height[0][2], left[0][3], top[0][4], width[0][5], z[0][6]})), new pixel(new Object({backgroundColor[1][0], border[1][1], height[1][2], left[1][3], top[1][4], width[1][5], z[1][6]})), new pixel(new Object({backgroundColor[2][0], border[2][1], height[2][2], left[2][3], top[2][4], width[2][5], z[2][6]})), new pixel(new Object({backgroundColor[3][0], border[3][1], height[3][2], left[3][3], top[3][4], width[3][5], z[3][6]}))],[new pixel(new Object({backgroundColor[4][0], border[4][1], height[4][2], left[4][3], top[4][4], width[4][5], z[4][6]})), new pixel(new Object({bacgkroundColor[5][0], border[5][1], height[5][2], left[5][3], top[5][4], width[5][5], z[5][6]})), new pixel(new Object({backgroundColor[6][0], border[6][1], height[6][2], left[6][3], top[6][4], width[6][5], z[6][6]})), new pixel(new Object({backgroundColor[7][0], border[7][1], height[7][2], left[7][3], top[7][4], width[7][5], z[7][6]}))],[new pixel(new Object({backgroundColor[8][0], border[8][1], height[8][2], left[8][3], top[8][4], width[8][5], z[8][6]})), new pixel(new Object({backgroundColor[9][0], border[9][1], height[9][2], left[9][3], top[9][4], width[9][5], z[9][6]})), new pixel(new Object({backgroundColor[10][0], border[10][1], height[10][2], left[10][3], top[10][4], width[10][5], z[10][6]})), new pixel(new Object({backgroundColor[11][0], border[11][1], height[11][2], left[11][3], top[11][4], width[11][5], z[11][6]}))], [new pixel(new Object({backgroundColor[12][0], border[12][1], height[12][2], left[12][3], top[12][4], width[12][5], z[12][6]})), new pixel(new Object({backgroundColor[13][0], border[13][1], height[13][2], left[13][3], top[13][4], width[13][5], z[13][6]})), new pixel(new Object({backgroundColor[14][0], border[14][1], height[14][2], left[14][3], top[14][4], width[14][5], z[14][6]})), new pixel(new Object({backgroundColor[15][0], border[15][1], height[15][2], left[15][3], top[15][4], width[15][5], z[15][6]})), new pixel(new Object(backgroundColor[16][0], border[16][1], height[16][2], left[16][3], top[16][4], width[16][5], z[16][6]]]) 


}
}










class sprite extends avatar{ 
constructor(){
super()
this.isNotEmpty = false
}

get(){
let avatar = new avatar()
this.isNotEmpty = true 



























return {hair: new new pixel().get(avatar.x[0][0], avatar.x[0][1], avatar.x[0][2], avatar.x[0][3], avatar.x[0][4], avatar.x[0][5], avatar.x[0][6]), hands: new pixel().get(avatar.x[1][0], avatar.x[1][1], avatar.x[1][2], avatar.x[1][3], avatar.x[1][4], avatar.x[1][5], avatar.x[1][6]), head: new pixel().get(avatar.x[2][0], avatar.x[2][1], avatar.x[2][2], avatar.x[2][3], avatar.x[2][4], avatar.x[2][5], avatar.x[2][6]), neck:  new pixel().get(avatar.x[3][0], avatar.x[3][1], avatar.x[3][2], avatar.x[3][3], avatar.x[3][4], avatar.x[3][5], avatar.x[3][6]) ,shirt: new pixel().get(avatar.x[4][0], avatar.x[4][1], avatar.x[4][1], avatar.x[4][2], avatar.x[4][3], avatar.x[4][4], avatar.x[4][5], avatar.x[4][6]), pants: new pixel().get(avatar.x[5][0], avatar.x[5][1], avatar.x[5][2], avatar.x[5][3], avatar.x[5][4], avatar.x[5][5], avatar.x[5][6]),shoes: new pixel().get(avatar.x[6][0], avatar.x[6][1], avatar.x[6][2], avatar.x[6][3], avatar.x[6][4], avatar.x[6][5], avatar.x[6][6])} 



}
}
class game extends avatar{
constructor(){
super()
this.avatar = new sprite().get() 
this.texture = new texture().get() 
}
getAvatar(){
if (this.avatar !== {}){
return document.querySelector('body').innerHTML += this.avatar.hair, this.avatar.head, this.avatar.hand, this.avatar.neck, this.avatar.shirt, this.avatar.pants, this.avatar.shoes 
}

}
class texture extends avatar{
constructor(){
this.isNotEmpty = false
}
getTexture(){
if (this.texture !== {}){
return document.querySelector('body').innerHTML += this.texture
}
}

document.querySelector('body').addEventListener('keydown', (key) => switch(key.code){case key.code == 'KeyD': 


const a = setInterval(() =>  
document.querySelector('body').childNodes[1].style.left = parseInt(document.querySelector('body').childNodes[1].style.width.charAt(0)) + parseInt(document.querySelector('body').childNodes[1].style.width.charAt(1)) + 10).concat('px')
)
break 
case key.code == 'KeyA':
const b = setInterval(() => 

document.querySelector('body').childNodes[1].style.left = parseInt(document.querySelector('body).childNodes[1].style.left.charAt(0)) + parseInt(document.querySelector('body').childNodes[1].style.left.charAt(1)) - 10).concat('px'))
break
case key.code == 'KeyW' => 
document.querySelector('body').childNodes[1].classList.add(punch)
break

case key.code == 'KeyS' => 
document.querySelector('body').childNodes[1].classList.add(kick)
break

}
)













document.querySelector('body').addEventListener('keyup', (key) => switch(key.code){case key.code == 'KeyD':



clearInterval(a)
break
case key.code == 'KeyA':
clearInterval(b)
break 
case key.code == 'KeyW':
document.querySelector('body').childNodes[1].classList.remove(punch
break
case key.code == 'KeyS':
document.querySelector('body').childNodes[1].classList.remove(kick)
break
}

)
document.querySelector('body').addEventListener('keydown', (key) if(key.code) == 'KeyV'){
document.querySelector('body').innerHTML += new menu()  

}

















document.querySelector('body').addEventListener('load', (game) => {document.querySelector('body').innerHTML += game.getTexture('green', 2, 30, 0, 70, 100, 100)
document.querySelector('body').innerHTML += game.getAvatar('orange', 2,40, 40, 40, 40)
})

let Agristores-technologies = new Object(`


Agristores technologies
Agristores technologies is an online Ecommerce platform

Policy
Introduction
Service Provider
These terms are between you and Agristores-technologies

Age and eligibility requirements
In order to use the Book MS and access any content you need to be 13 years of age (or equivalent minimum age in your country) or older, have parental or guardian consent if you are a minor in your home country, have the power to enter into a binding contract with us and not be barred from doing so under any applicable laws, reside in a country where the service is available

Agristores-technologies Provided By Us
Agristores-technologies Options
We provide numerous Agristores-technologies Options

Trials
From time to time we or others on our behalf may offer trials of paid subscription for a specified period without payment or at a reduced rate Third Party Applications, Devices and Open Source Software

Third-Party Applications, Devices And Open Source Software
The Agristores-technologies may be integrated with, or may otherwise interact with third party applications websites and services and third-party personal computers and mobile handsets tablets wearable devices speakers and other devices

Service Limitations and Modifications
We use reasonable Care and skill to keep the Book MS operational

Your Use of The Agristores-technologies
Creating a Book MS account
You may need to create a Agristores-technologies Account to use

Your rights to use the Agristores-technologies
Access to Agristores-technologies
Subject to your compliance with these Terms, we grant you limited, non-exclusive, revocable permission to make personal non-commercial use of the Agristores-technologies and the Content

Agristores-technologies's proprietary rights
The Agristores-technologies and the content are the property of Book MS or Agristores-technologies's licensors

Payments and cancellation
You may purchase a Paid Subscription directly from Agristores-technologies or through a third party by Paying
`
</script>
</html>

